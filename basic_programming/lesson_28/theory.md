<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>


# Коллекции. List. ArrayList

Итак, ***LinkedList\*** — класс, реализующий два интерфейса — ***List\*** и ***Deque\***. Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и *null*) элементов. Каждый объект, помещенный в связанный список, является узлом (нодом). Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.
![img](https://habrastorage.org/r/w1560/web/7ef/7e6/108/7ef7e61084874c1dba800c0fcdc9d254.jpg)
Разберемся, что же происходит, когда мы пишем уже простые и привычные строки кода.



## 1. Создание связанного списка



```
LinkedList<Integer> numbers = new LinkedList<>();
```


Данный код создает объект класса ***LinkedList\*** и сохраняет его в ссылке *numbers*. Созданный объект предназначен для хранения целых чисел (***Integer\***). Пока этот объект пуст.

Класс ***LinkedList\*** содержит три поля:



```
int size = 0;
Node<E> first;
Node<E> last;
```


![img](https://habrastorage.org/r/w1560/web/5fd/a4c/d01/5fda4cd01a064bbfa2e5ab2b6196510f.jpg)



## 2. Добавление объекта в конец связанного списка



```
numbers.add(8);
```


Данный код добавляет число 8 в конец ранее созданного списка. Под «капотом» этот метод вызывает ряд других методов, обеспечивающих создание объекта типа ***Integer\***, создание нового узла, установку объекта класса ***Integer\*** в поле *item* этого узла, добавление узла в конец списка и установку ссылок на соседние узлы.

Для установки ссылок на предыдущий и следующий элементы ***LinkedList\*** использует объекты своего вложенного класса ***Node\***:



```
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```


При каждом добавлении объекта в список создается один новый узел, а также изменяются значения полей связанного списка (*size*, *first*, *last*).
![img](https://habrastorage.org/r/w1560/web/e9c/521/602/e9c521602c054d549650a6c3e9f05b8f.jpg)
В случае с добавлением первого элемента создается узел, у которого предыдущий и следующий элементы отсутствуют, т.е. являются *null*, размер коллекции увеличивается на 1, а созданный узел устанавливается как первый и последний элемент коллекции.

Добавим еще один элемент в нашу коллекцию:



```
numbers.add(5);
```


Сначала создается узел для нового элемента (число 5) и устанавливается ссылка на существующий элемент (узел с числом 8) коллекции как на предыдущий, а следующим элементом у созданного узла остается *null*. Также этот новый узел сохраняется в переменную связанного списка *last*:
![img](https://habrastorage.org/r/w1560/web/752/148/b39/752148b39c0b41b4a870f477bc537706.jpg)
Как можно увидеть на рис. 4, первый элемент коллекции (под индексом 0) пока ссылается на *null* как на следующий элемент. Теперь эта ссылка заменяется и первый элемент начинает ссылаться на второй элемент коллекции (под индексом 1), а также увеличивается размер коллекции:
![img](https://habrastorage.org/r/w1560/web/8a2/34a/aed/8a234aaedda6454480c0e443459e5085.jpg)

## 3. Добавление объекта в середину связанного списка



```
numbers.add(1, 13);
```


***LinkedList\*** позволяет добавить элемент в середину списка. Для этого используется метод **add(index, element)**, где *index* — это место в списке, куда будет вставлен элемент element.

Как и метод **add(element)**, данный метод вызывает несколько других методов. Сначала осуществляется проверка значения *index*, которое должно быть положительным числом, меньшим или равным размеру списка. Если *index* не удовлетворит этим условиям, то будет сгенирировано исключение *IndexOutOfBoundsException*.

Затем, если *index* равен размеру коллеции, то осуществляются действия, описанные в п. 2, так как фактически необходимо вставить элемент в конец существующего списка.

Если же *index* не равен *size* списка, то осуществляется вставка перед элементом, который до этой вставки имеет заданный индекс, т.е. в данном случае перед узлом со значением 5.

Для начала с помощью метода **node(index)** определяется узел, находящийся в данный момент под индексом, под который нам необходимо вставить новый узел. Поиск данного узла осуществляется с помощью простого цикла for по половине списка (в зависимости от значения индекса — либо с начала до элемента, либо с конца до элемента). Далее создается узел для нового элемента (число 13), ссылка на предыдущий элемент устанавливается на узел, в котором элементом является число 8, а ссылка на следующий элемент устанавливается на узел, в котором элементом является число 5. Ссылки ранее существующих узлов пока не изменены:
![img](https://habrastorage.org/r/w1560/web/683/17e/f19/68317ef19e6b410c9504b4447f675219.jpg)
Теперь последовательно заменяются ссылки: для элемента, следующего за новым элементом, заменяется ссылка на предыдущий элемент (теперь она указывает на узел со значением 13), для предшествующего новому элементу заменяется ссылка на следующий элемент (теперь она указывает на узел со значением 5). И в последнюю очередь увеличивается размер списка:
![img](https://habrastorage.org/r/w1560/web/6e0/0bc/c0d/6e00bcc0d32242b399ead4d13646b03d.jpg)

## 4. Удаление объекта из списка


Для удаления одного элемента из списка класс ***LinkedList\*** предлагает нам аж 10 методов, различающихся по типу возвращаемого значения, наличию или отсутствию выбрасываемых исключений, а также способу указания, какой именно элемент следует удалить:
![img](https://habrastorage.org/r/w1560/web/52e/b4d/075/52eb4d07565e444e966ebeb652dd8202.jpg)
Рассмотрим удаление элемента из связанного списка по его значению. Удалим элемент со значением 5 из нижепредставленного списка:
![img](https://habrastorage.org/r/w1560/web/884/079/b6c/884079b6c6d9434bb0fecbcc0235c269.jpg)

```
numbers.remove(Integer.valueOf(5));
```


Обратите внимание, что принимаемым значением в методе **remove(object)** является именно объект, если же мы попытаемся удалить элемент со значением 5 следующей строкой

```
numbers.remove(5);
```


то получим *IndexOutOfBoundsException*, т.к. компиллятор воспримет число 5 как индекс и вызовет метод **remove(index)**.

Итак, что же происходит при вызове метода **remove(object)**? Сначала искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого узла. Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной. Потом переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга:
![img](https://habrastorage.org/r/w1560/web/700/fc4/1dd/700fc41dd4fb47f18be9f932639fb2bd.jpg)
Затем обнуляется значение узла, который содержит удаляемый объект, а также уменьшается размер коллекции:
![img](https://habrastorage.org/r/w1560/web/b40/5b7/b4f/b405b7b4fddd4ff6b1a868ae9758944c.jpg)
Теперь вернемся к тому моменту, что элемент из удаляемого узла мы сохраняли в памяти. Зачем мы это делали, спросите вы, если эти данные мы нигде дальше не использовали. Дело в том, что рассматриваемый нами метод в результате своей работу не возвращает удаленный элемент, потому данные, возврещенные вызванным в рамках работы метода **unlink(node)**, вызванного методом **remove(object)**, просто не понадобились. А вот когда мы используем метод **remove(index)**, также вызывающий метод **unlink(node)**, то значение данного элемента последовательно возвращается сначала методом **unlink(node)**, а затем и методом **remove(index)**. Похожая ситуация наблюдается и в остальных методах, возвращающих значение удаленного элемента, только внутри вызываются другие методы, отсоединяющие ссылку: в методах **poll()**, **pollFirst()**, **remove()** и **removeFirst()** это метод **unlinkFirst(node)**, а в методах **pollLast()** и **removeLast()** — метод **unlinkLast(node)**.

Итак, что следует помнить о ***LinkedList\***, решая, использовать ли данную коллекцию:

- позволяет хранить любые объекты, в том числе *null* и повторяющиеся;
- за константное время *O(1)* выполняются операции вставки и удаления первого и последнего элемента, операции вставки и удаления элемента из середины списка (не учитывая время поиска позиции элемента, который осуществляется за линейное время);
- за линейное время *O(n)* выполняются операции поиска элемента по индексу и по значению.



</details>
