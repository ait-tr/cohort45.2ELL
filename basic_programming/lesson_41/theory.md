<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>



## Аннотации BeforeEach и BeforeAll в JUnit 5

### Введение

Аннотации `@BeforeEach` и `@BeforeAll` в JUnit 5 используются для определения методов, которые будут выполняться **до** запуска тестов. Это позволяет настроить окружение для тестирования и избежать дублирования кода.

### @BeforeEach

- Выполняется **перед каждым** тестовым методом в классе.
- Идеально подходит для инициализации объектов или ресурсов, которые должны быть **уникальными** для каждого теста.
- Гарантирует **чистоту** тестового окружения, предотвращая побочные эффекты от предыдущих тестов.

**Пример:**

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class MyTests {

    List<String> list;

    @BeforeEach
    void setUp() {
        list = new ArrayList<>();
    }

    @Test
    void testAdd() {
        list.add("element");
        assertEquals(1, list.size());
    }

    @Test
    void testRemove() {
        list.add("element");
        list.remove(0);
        assertEquals(0, list.size());
    }
}
```

В этом примере метод `setUp()` с аннотацией `@BeforeEach` создает новый список `list` перед каждым тестом, обеспечивая чистую среду для каждого теста.

### @BeforeAll

- Выполняется **один раз** перед всеми тестами в классе.
- Подходит для инициализации **общих ресурсов**, например, подключения к базе данных, загрузки файлов конфигурации.
- **Ускоряет** выполнение тестов, так как ресурсоемкие операции выполняются только один раз.

**Пример:**

```java
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

class MyTests {

    static Connection connection;

    @BeforeAll
    static void setUpConnection() {
        // Устанавливаем соединение с базой данных
        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "user", "password");
    }

    @Test
    void testQuery() {
        // Используем установленное соединение для выполнения запроса
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM mytable");
        // ...
    }
}
```

В этом примере метод `setUpConnection()` с аннотацией `@BeforeAll` устанавливает соединение с базой данных один раз перед всеми тестами, что экономит время и ресурсы.

### Важные моменты

- Методы с `@BeforeAll` должны быть **статическими**.
- Методы с `@BeforeEach` и `@BeforeAll` должны быть **public** или **package-private**.
- Порядок выполнения методов: `@BeforeAll` -> `@BeforeEach` -> `@Test` -> `@AfterEach` -> `@AfterAll`.

### Заключение

Аннотации `@BeforeEach` и `@BeforeAll` являются мощными инструментами JUnit 5, которые помогают писать чистый, эффективный и поддерживаемый код тестов. Используйте их с умом для настройки тестового окружения и повышения качества вашего кода.

## System.out.printf() в Java: форматированный вывод

`System.out.printf()` - это мощный инструмент в Java, который позволяет выводить данные в консоль в отформатированном виде. Он похож на функцию `printf()` из языка C и предоставляет гибкий способ управления отображением чисел, строк и других типов данных.

### Базовый синтаксис

```java
System.out.printf(форматная_строка, аргумент1, аргумент2, ...);
```

- **форматная_строка:** строка, которая определяет формат вывода. Она может содержать обычный текст и **спецификаторы формата**, которые начинаются со знака процента (`%`).
- **аргумент1, аргумент2, ...:** переменные или значения, которые будут вставлены в форматную строку.

### Спецификаторы формата

Спецификаторы формата указывают, как именно нужно отобразить аргумент. Вот некоторые из наиболее распространенных:

| Спецификатор | Описание | Пример |
|---|---|---|
| `%d` | Десятичное целое число | `%d` для `123` выведет `123` |
| `%f` | Десятичное число с плавающей точкой | `%.2f` для `3.14159` выведет `3.14` |
| `%s` | Строка | `%s` для `"Hello"` выведет `Hello` |
| `%c` | Символ | `%c` для `'A'` выведет `A` |
| `%n` | Перевод строки | `%n` перейдет на новую строку |

### Модификаторы формата

Модификаторы формата позволяют дополнительно настроить отображение аргумента. Они добавляются между знаком процента и спецификатором формата.

| Модификатор | Описание | Пример |
|---|---|---|
| `-` | Выравнивание по левому краю | `%-10s` выровняет строку по левому краю в поле шириной 10 символов |
| `+` | Обязательный знак (+/-) для чисел | `%+d` выведет `+123` для положительных чисел |
| `0` | Дополнение нулями слева | `%05d` выведет `00123` для числа `123` |
| `(ширина)` | Минимальная ширина поля | `%10s` выделит для строки поле шириной не менее 10 символов |
| `.(точность)` | Количество знаков после запятой для чисел с плавающей точкой | `%.2f` выведет число с двумя знаками после запятой |

### Примеры

```java
int age = 25;
String name = "John";
double balance = 1234.5678;

System.out.printf("Имя: %s, возраст: %d%n", name, age);
System.out.printf("Баланс: %.2f рублей%n", balance);
System.out.printf("Телефон: +%012d%n", 79123456789L);
```

Вывод:

```
Имя: John, возраст: 25
Баланс: 1234.57 рублей
Телефон: +79123456789
```

### Заключение

`System.out.printf()` - это мощный инструмент для форматированного вывода в Java. Используя спецификаторы и модификаторы формата, вы можете точно контролировать отображение данных в консоли, что делает ваш код более читаемым и информативным.


## Вложенные классы в Java: Nested и Inner

В Java классы могут быть определены внутри других классов. Такие классы называются **вложенными (nested)**. Вложенные классы - это мощный инструмент для организации кода, повышения инкапсуляции и создания более гибких и удобных решений.

Существует два вида вложенных классов:

1. **Статические вложенные классы (static nested classes)**
2. **Внутренние классы (inner classes)**:
    * **Классы-члены (member inner classes)**
    * **Локальные классы (local inner classes)**
    * **Анонимные классы (anonymous inner classes)**

### 1. Статические вложенные классы

- Объявляются со словом `static` перед ключевым словом `class`.
- Могут обращаться **только к статическим** членам внешнего класса.
- Используются как "вспомогательные" классы, логически связанные с внешним классом, но не требующие доступа к его экземпляру.

**Пример:**

```java
class OuterClass {
    static int outerStaticVariable = 10;

    static class StaticNestedClass {
        void printVariable() {
            System.out.println("Static variable: " + outerStaticVariable); 
        }
    }
}

OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
nestedObject.printVariable(); // Вывод: "Static variable: 10"
```

### 2. Внутренние классы (Inner classes)

#### 2.1 Классы-члены (Member inner classes)

- Определяются **внутри тела внешнего класса**, но **вне** его методов.
- Имеют доступ **ко всем** членам внешнего класса (статическим и нестатическим).
- Для создания экземпляра требуется **сначала создать экземпляр внешнего класса**.

**Пример:**

```java
class OuterClass {
    private int outerVariable = 5;

    class MemberInnerClass {
        void printVariable() {
            System.out.println("Outer variable: " + outerVariable);
        }
    }
}

OuterClass outerObject = new OuterClass();
OuterClass.MemberInnerClass innerObject = outerObject.new MemberInnerClass();
innerObject.printVariable(); // Вывод: "Outer variable: 5"
```

#### 2.2 Локальные классы (Local inner classes)

- Определяются **внутри метода** внешнего класса.
- Имеют доступ **только к `final`** локальным переменным и **всем** членам внешнего класса.
- Используются для создания классов, специфичных для конкретного метода.

**Пример:**

```java
class OuterClass {
    void myMethod() {
        final int num = 10; 

        class LocalInnerClass {
            void printNum() {
                System.out.println("Number: " + num);
            }
        }

        LocalInnerClass inner = new LocalInnerClass();
        inner.printNum(); // Вывод: "Number: 10"
    }
}
```

#### 2.3 Анонимные классы (Anonymous inner classes)

- **Создаются и инстанцируются** в одном выражении.
- Используются для создания одноразовых реализаций интерфейсов или расширения классов.

**Пример:**

```java
interface MyInterface {
    void myMethod();
}

class MyClass {
    public void myMethod() {
        MyInterface myImpl = new MyInterface() {
            @Override
            public void myMethod() {
                System.out.println("Implementation of myMethod");
            }
        };

        myImpl.myMethod(); // Вывод: "Implementation of myMethod"
    }
}
```

### Преимущества использования вложенных классов:

- **Инкапсуляция:** скрытие реализации от внешнего мира.
- **Организация кода:** группировка связанных классов.
- **Удобство:** доступ к членам внешнего класса.
- **Гибкость:** создание специализированных классов внутри методов.

Вложенные классы - важная часть языка Java, которая позволяет писать более чистый, организованный и эффективный код.


## Varargs (Variable Arguments) в Java: Гибкость методов

Varargs (сокращение от "variable arguments") - это
механизм в Java, который позволяет методу принимать
**переменное количество аргументов** одного типа.
Это избавляет от необходимости создавать
перегруженные методы для каждого  
возможного количества аргументов.

### Объявление метода с varargs:

```java
тип_возвращаемого_значения имя_метода(тип_аргумента... имя_аргумента) {
    // Тело метода
}
```

- **три точки (...)** после типа аргумента указывают, что
  метод принимает varargs.
- `имя_аргумента`  - это массив,
  содержащий все переданные аргументы.

### Пример:

```java
public class VarargsExample {

    public static void printNumbers(int... numbers) {
        for (int number : numbers) {
            System.out.print(number + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        printNumbers(1, 2, 3); // Вывод: 1 2 3 
        printNumbers(10, 20); // Вывод: 10 20 
        printNumbers(); // Вывод: пустая строка
    }
}
```

В этом примере метод `printNumbers` принимает
любое количество аргументов типа `int`.
Внутри метода `numbers` обрабатывается как обычный массив.

### Важные моменты:

* Метод может иметь **только один** параметр varargs.
* Параметр varargs **должен быть последним**
  в списке параметров метода.
* Можно передавать **массив** в качестве
  аргумента методу с varargs.

### Преимущества использования varargs:

- **Упрощение кода:** избавление от
  перегруженных методов.
- **Повышение читаемости:**
  код становится более лаконичным.
- **Гибкость:**  методы могут
  принимать любое количество аргументов.

### Заключение:

Varargs - это мощный инструмент в Java,
который делает код более гибким и
удобным для чтения. Используйте
varargs, когда ваш метод должен
работать с переменным количеством
аргументов одного типа.


## Дефолтные методы в интерфейсах Java: Гибкость и обратная совместимость

До Java 8 интерфейсы могли содержать только абстрактные методы, которые должны были быть реализованы классами-наследниками.  
**Java 8 представила дефолтные методы в интерфейсах**, что позволило добавлять новые методы в интерфейсы, не нарушая совместимость с существующим кодом.

### Что такое дефолтный метод?

Дефолтный метод — это метод интерфейса, у которого есть реализация по умолчанию.
Он определяется с помощью ключевого слова `default` перед объявлением метода.

```java
public interface MyInterface {

    // Абстрактный метод
    void abstractMethod();

    // Дефолтный метод
    default void defaultMethod() {
        System.out.println("Это дефолтный метод.");
    }
}
```

### Преимущества дефолтных методов:

* **Обратная совместимость:** Добавление дефолтных методов в существующий интерфейс не нарушает работу классов, которые его уже реализуют.
* **Расширение функциональности:** Интерфейсы могут быть расширены новыми методами без необходимости изменять все классы-наследники.
* **Множественное наследование поведения:** Классы могут наследовать поведение от нескольких интерфейсов, включая дефолтные методы.

### Как использовать дефолтные методы?

Классы, реализующие интерфейс с дефолтными методами, могут:

* **Использовать дефолтную реализацию**:  Если классу подходит поведение по умолчанию, то он может не переопределять дефолтный метод.
* **Переопределить дефолтную реализацию**: Класс может предоставить свою собственную реализацию дефолтного метода, если требуется другое поведение.

```java
public class MyClass implements MyInterface {

    @Override
    public void abstractMethod() {
        // Реализация абстрактного метода
    }

    // Дефолтный метод defaultMethod() не переопределен, 
    // используется реализация по умолчанию из интерфейса
}
```

### Разрешение конфликтов дефолтных методов:

Если класс наследует несколько интерфейсов с одинаковыми дефолтными методами, возникает конфликт.
Для его разрешения необходимо:

* **Явно указать, какой метод использовать**:
    ```java
    Interface1.super.defaultMethod();
    ```
* **Переопределить метод в классе**:
    ```java
    @Override
    public void defaultMethod() {
        // Собственная реализация
    }
    ```

### Заключение:

Дефолтные методы в интерфейсах — это мощный инструмент, который повышает гибкость и расширяемость кода, сохраняя при этом обратную совместимость.
Они позволяют добавлять новые функции в интерфейсы, не нарушая работу существующего кода, и предоставляют больше возможностей для реализации множественного наследования поведения.


</details>
