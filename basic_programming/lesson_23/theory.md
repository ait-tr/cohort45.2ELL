<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>
## Оценка алгоритмов
# Сортировка и поиск

**Поиск в программировании** - это ключевая операция, направленная на нахождение элемента в наборе данных или определение его точной позиции. Один из простейших алгоритмов поиска - линейный поиск, который осуществляется путем последовательного перебора элементов в данных. Этот метод особенно полезен, когда структура данных не упорядочена и не имеет каких-либо специальных свойств. Однако, линейный поиск может быть неэффективным на больших объемах данных, особенно в худшем случае, когда искомый элемент отсутствует в коллекции. В таких ситуациях алгоритму приходится проверять каждый элемент, что приводит к увеличению времени выполнения. Это подчеркивает важность выбора подходящего алгоритма поиска в зависимости от характера и размера набора данных.
![img](https://lh7-us.googleusercontent.com/xWhZR1MZ2p3N63eZYjEqr6C8LPz-BpfCPEGoOxXlHkKwtvgUAbTFvRlqOCYTA2WgmBDExvG5I092MJaUc3ujUHKkia_TVuhG48kohoNgCj-n6SBSLIPar5aux6QUt3auguuzShq995BtnbhpdtYBmpM)
**Бинарный поиск** - это эффективный алгоритм поиска, который находит широкое применение в случаях, когда данные уже упорядочены. Принцип его работы схож с методом поиска слова в словаре: вместо того чтобы перебирать все слова, мы делим словарь на половины до тех пор, пока не найдем нужное слово. В контексте бинарного поиска это означает, что при каждом шаге алгоритм сравнивает искомый элемент с элементом в середине диапазона, сокращая область поиска вдвое. Это значительно ускоряет поиск по сравнению с линейным методом, особенно в больших наборах данных. Таким образом, бинарный поиск идеально подходит для быстрого нахождения элементов в больших и упорядоченных наборах данных, предлагая высокую эффективность и скорость выполнения по сравнению с другими алгоритмами поиска.





Рассмотрим пример поиска числа **23** в массиве:![img](https://lh7-us.googleusercontent.com/h0YrASYJGw0bUQrHVK9F1lj9CP0CutHof0_I_cCXLezvBmJayXo_wY5hEQe1LIAxImLh6r-GFDIe6xFT7HrHrkpTdIzoB-8GnXzuTd6pmZdaiOBwlvOXNqyscr6xClhsmYWofJcW5DpZN06J3Sltt3A)![img](https://lh7-us.googleusercontent.com/SFyPo6TapSJCNHcI2VK0KE9Z4KISQHk50vfd9VKOma6GYWnOSdk8Xmxtu0I6rwoQjZdwMG5Y4GLOSUKhd4UgxJsNI5VHrAmbWX_Z1bjRfja97R0og7h4ibBqu9pTRmTBHhPAfk0eS4DJY2AOAvD-kLw)![img](https://lh7-us.googleusercontent.com/tUF_T8tzpXKJEL9YacENA8iVz69c1_PjjDEwh_kbBl56VGD59VvVenG3qxTL0ko32flSSlJ7rwW2etQPWElAQugThz2Y14_XqslavSGzUvqOU2wM_VrF5DICizTeVe3KBCx4xWYuE7wyXfUk6Q4LefM)![img](https://lh7-us.googleusercontent.com/pQsU432nrCoqn_C1nfzBFd-0IlMAevLADgiNnlHhxWoWPfEGMeKkGYe3LwRRNv46SxhfYLCChh1LqYC4Iov9lVVsUn05lYmpWFRRxJV0QleuuQajjXQ32d3WDYXBeOiOOHq9aXL3SPeKVaryFhdKMTA)Таким образом, было выполнено только **3 сравнения**.


**Сортировка** - это фундаментальный процесс в области компьютерных наук, который заключается в упорядочивании элементов в наборе данных согласно определенному критерию, например, по возрастанию или убыванию. Один из ключевых аспектов сортировки - это её способность ускорить процессы поиска, так как упорядоченные данные позволяют использовать более эффективные методы поиска, такие как бинарный поиск. Существует множество алгоритмов сортировки, каждый из которых имеет свои особенности и подходит для различных сценариев использования.
Одним из простейших примеров является алгоритм **сортировки выбором** (**selection sort**). Этот алгоритм работает, последовательно находя наименьший (или наибольший) элемент из неотсортированной части массива и обменивая его с первым неотсортированным элементом. Несмотря на свою простоту, сортировка выбором не является самым быстрым алгоритмом, особенно на больших наборах данных. Однако, его легкость в понимании и реализации делает его хорошим выбором для введения в концепции сортировки. Сортировка выбором иллюстрирует важный принцип в алгоритмах сортировки - баланс между эффективностью и сложностью, позволяющий выбирать оптимальный метод в зависимости от конкретной задачи и объема данных.
Сортировка выбором (Selection Sort) на наборе данных [8, 6, 2, 5, 1] происходит следующим образом:
**Первый проход:**
Находим минимальный элемент во всем массиве. Минимальный элемент - 1.Меняем местами 1 и первый элемент массива (8).Новый массив: [1, 6, 2, 5, 8].
**Второй проход:**
Игнорируем уже отсортированный элемент (1) и ищем минимальный элемент в оставшейся части массива. Минимальный элемент - 2.Меняем местами 2 и первый элемент из неотсортированной части (6).Новый массив: [1, 2, 6, 5, 8].
**Третий проход:**
Продолжаем игнорировать отсортированную часть (1, 2) и находим минимальный элемент в оставшейся части. Здесь это 5.Меняем местами 5 и первый элемент из неотсортированной части (6).Новый массив: [1, 2, 5, 6, 8].



**Четвертый проход:**
Игнорируем уже отсортированные элементы (1, 2, 5) и выбираем минимальный из оставшихся. Это 6, который уже находится на своем месте.Поскольку 6 уже находится на своей позиции, никаких обменов не происходит.Новый массив: [1, 2, 5, 6, 8].Пятый проход:
Остается только один элемент (8), который уже находится на своем месте.Массив уже полностью отсортирован: [1, 2, 5, 6, 8].
![img](https://lh7-us.googleusercontent.com/-LGMlVlCa8pjQFoR-YNhPD_qNARmIsl6HSs98D-uQK8QwkMhSDtAAy2JsSIT-oH6wnBlwdrej4N53NlvWOWj8kmrsbxdNyPRCbkvRgW290BV9UifaZ8XCBgj8-NRKJnWMWTGgPSunV-k5ejM75Qfbis)



</details>
