<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>


# Коллекции. List. ArrayList

Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции. Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и ряд других.

Классы коллекций располагаются в пакете `java.util`, поэтому перед применением коллекций следует подключить данный пакет.

Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. Среди этих интерфейсов можно выделить следующие:

- **Collection**: базовый интерфейс для всех коллекций и других интерфейсов коллекций
- **Queue**: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди
- **Deque**: наследует интерфейс Queue и представляет функционал для двунаправленных очередей
- **List**: наследует интерфейс Collection и представляет функциональность простых списков
- **Set**: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов
- **Map**: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection

С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:

- **ArrayList**: простой список объектов
- **LinkedList**: представляет связанный список
- **ArrayDeque**: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце
- **HashSet**: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код
- **TreeSet**: набор отсортированных объектов в виде дерева
- **LinkedHashSet**: связанное хеш-множество
- **PriorityQueue**: очередь приоритетов
- **HashMap**: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение
- **TreeMap**: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение

### List

Для создания простых списков применяется интерфейс List, который расширяет функциональность интерфейса Collection. Некоторые наиболее часто используемые методы интерфейса List:

```
void add(int index, E obj): добавляет в список по индексу index объект obj

E get(int index): возвращает объект из списка по индексу index

E remove(int index): удаляет объект из списка по индексу index, возвращая при этом удаленный объект

E set(int index, E obj): присваивает значение объекта obj элементу, который находится по индексу index
```

### ArrayList

По умолчанию в Java есть встроенная реализация этого интерфейса - класс ArrayList. Класс ArrayList представляет обобщенную коллекцию, которая наследует свою функциональность от класса AbstractList и применяет интерфейс List. Проще говоря, ArrayList представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.

Внутри ArrayList содержится массив, размер которого определяется величиной capacity (по умолчанию равен 10). При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости ArrayList позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.

Используем класс ArrayList и некоторые его методы в программе:

```
import java.util.ArrayList;

public class Program{

    public static void main(String[] args) {
          
        ArrayList<String> people = new ArrayList<String>();
        // добавим в список ряд элементов
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        people.add("Sam");
        people.add(1, "Bob"); // добавляем элемент по индексу 1
          
        System.out.println(people.get(1));// получаем 2-й объект
        people.set(1, "Robert"); // установка нового значения для 2-го объекта
          
        System.out.printf("ArrayList has %d elements \n", people.size());
        for(String person : people){
          
            System.out.println(person);
        }
        // проверяем наличие элемента
        if(people.contains("Tom")){
          
            System.out.println("ArrayList contains Tom");
        }
          
        // удалим несколько объектов
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);
         
    }

}
```


Здесь объект ArrayList типизируется классом String, поэтому список будет хранить только строки. Поскольку класс ArrayList применяет интерфейс Collection<E>, то мы можем использовать методы данного интерфейса для управления объектами в списке.

Для добавления вызывается метод add. С его помощью мы можем добавлять объект в конец списка: people.add("Tom"). Также мы можем добавить объект на определенное место в списке, например, добавим объект на второе место (то есть по индексу 1, так как нумерация начинается с нуля): people.add(1, "Bob")

Метод size() позволяет узнать количество объектов в коллекции.

Проверку на наличие элемента в коллекции производится с помощью метода contains. А удаление с помощью метода remove. И так же, как и с добавлением, мы можем удалить либо конкретный элемент people.remove("Tom");, либо элемент по индексу people.remove(0); - удаление первого элемента.

Получить определенный элемент по индексу мы можем с помощью метода get(): String person = people.get(1);, а установить элемент по индексу с помощью метода set: people.set(1, "Robert");

С помощью метода toArray() мы можем преобразовать список в массив объектов.

Хотя мы можем свободно добавлять в объект ArrayList дополнительные объекты, в отличие от массива, однако в реальности ArrayList использует для хранения объектов опять же массив. По умолчанию данный массив предназначен для 10 объектов. Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. Подобные перераспределения памяти уменьшают производительность. Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, 25, то мы можем сразу же явным образом установить это количество, либо в конструкторе: ArrayList<String> people = new ArrayList<String>(25);, либо с помощью метода ensureCapacity: people.ensureCapacity(25);



</details>
