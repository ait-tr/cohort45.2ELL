<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>


# Теория

## Конструкторы

Конструктор выполняет инициализацию объекта непосредственно после его создания. Этот специальный блок инструкций задает начальное состояние объекта, внося начальные значения в его поля, что позволяет объекту быть готовым к использованию сразу после создания. Инициализация объекта обеспечивает установку определенных значений для всех его атрибутов, гарантируя, что объект начинает свою работу в предсказуемом и контролируемом состоянии.

Конструктор по умолчанию в языках программирования, поддерживающих ООП, таких как Java, — это конструктор без параметров, который автоматически генерируется компилятором для любого класса, если только разработчик явно не определил другой конструктор. Этот конструктор не содержит кода инициализации и предоставляет самые базовые условия для создания объекта. Однако, если в классе явно определен один или несколько пользовательских конструкторов с параметрами или без них, компилятор не добавляет конструктор по умолчанию автоматически, ожидая, что разработчик полностью контролирует процесс инициализации объектов своего класса.

```
class Human {

// поля
int age;
boolean isEmployed;
String name;

	// собственный конструктор без параметров
	Human() {
		age = 18;
		isEmployed = true;
		name = “Anonymous”;

}
}
```

// h1 ссылается на работающего человека 18 -ти лет с именем Anonymous
Human h1 = new Human();

Пример с классом Human демонстрирует создание собственного конструктора без параметров. В этом конструкторе полям age, isEmployed и name присваиваются начальные значения, таким образом определяя начальное состояние каждого объекта Human как 18-летнего трудоустроенного человека с именем "Anonymous". Это позволяет разработчику обеспечить более глубокий контроль над процессом создания объектов, задавая конкретные начальные характеристики, которые соответствуют логике и требованиям приложения.

Класс может содержать множество конструкторов, каждый из которых отличается набором формальных параметров. Эта возможность называется перегрузкой конструкторов и служит для предоставления различных способов инициализации объектов одного и того же класса. Перегруженные конструкторы позволяют создавать экземпляры класса с разными начальными состояниями, в зависимости от предоставленных аргументов или их отсутствия, что обеспечивает гибкость в процессе разработки программ.

```
class Human {
// …
// конструктор без параметров
Human() {
age = 18;
isEmployed = true;
name = “Anonymous”;
}

// конструктор с параметрами
Human(int a, boolean emp, String n) {
age = a;
isEmployed = emp;
name = n;
}
}
```

// имеем возможность использовать оба конструктора для создания объектов

Human h1 = new Human();

Human h2 = new Human(33, false, “Max”);

В приведенном примере мы видим два различных конструктора: один без параметров и один с параметрами. Конструктор без параметров инициализирует объекты с некоторым предопределенным состоянием, в данном случае устанавливая возраст в 18 лет, статус занятости в true и имя в "Anonymous". Это обеспечивает удобный способ создания объектов с стандартным набором начальных значений без необходимости явно указывать их каждый раз при создании нового объекта.

С другой стороны, конструктор с параметрами позволяет явно задать значения для полей age, isEmployed, и name при создании объекта, что дает возможность инициализировать объект с конкретными характеристиками, отличными от стандартных. Это особенно полезно, когда нужно создать объект с уникальными свойствами, отражающими конкретные требования или условия.
this

Ключевое слово this является важным инструментом, который используется внутри конструкторов и методов класса. Оно служит ссылкой на текущий объект — экземпляр класса, в контексте которого вызван конструктор или метод. Использование this позволяет однозначно идентифицировать поля и методы объекта, особенно в ситуациях, когда имена параметров метода или конструктора совпадают с именами полей класса, что может привести к коллизии имен.

```
class Human {
// …

Human(int age, boolean isEmployed, String name) {
this.age = age;
this.isEmployed = isEmployed;
this.name = name;
}
}
```

В приведенном примере конструктор принимает три параметра (age, isEmployed, name), имена которых совпадают с именами полей класса. Чтобы правильно инициализировать поля объекта значениями, переданными в конструктор, и избежать путаницы между полями класса и параметрами конструктора, используется ключевое слово this. Префикс this перед именем поля (this.age, this.isEmployed, this.name) указывает, что присваивание должно производиться именно полям текущего объекта, а не локальным переменным и параметрам.

Такой подход не только разрешает конфликт имен, но и повышает читаемость кода, делая явным обращение к атрибутам и методам объекта. Использование this подчеркивает, что операция или доступ осуществляются в контексте текущего экземпляра класса, что особенно полезно в сложных классах с множеством полей и методов.


Ключевое слово this обладает дополнительной функциональностью, позволяя не только обращаться к полям и методам текущего объекта, но и вызывать один конструктор класса из другого. Эта возможность особенно ценна для минимизации дублирования кода при инициализации объектов класса, когда несколько конструкторов выполняют общие операции инициализации, но также включают дополнительные шаги для разных вариантов создания объектов.

```
class Human {
// …
Human() {
age = 18;
isEmployed = true;
name = “Anonymous”;
}

Human(String name) {
this(); // вызов первого конструктора
this.name = name; // инициализация имени
}
}
```

В примере представлен метод вызова конструктора без параметров из конструктора с параметром name. Конструктор без параметров задает начальные значения для полей age, isEmployed и name, обеспечивая базовую инициализацию объекта. В конструкторе, принимающем параметр name, сначала выполняется вызов конструктора без параметров с помощью this(), что гарантирует, что все поля объекта будут инициализированы базовыми значениями. Затем, поле name инициализируется переданным значением, позволяя таким образом дополнить или изменить начальное состояние объекта без необходимости повторного кодирования инициализации общих полей.

### Массив объектов

В Java, как и во многих других объектно-ориентированных языках программирования, массив объектов представляет собой мощный инструмент для хранения и управления коллекциями объектов одного типа. Создание массива объектов в Java подразумевает инициализацию массива объектных переменных, где каждая переменная может хранить ссылку на объект определенного класса. Важным моментом при работе с массивами объектов является то, что после инициализации массива все его элементы по умолчанию инициализируются значением null, что означает отсутствие ссылки на какой-либо объект.

Пример создания массива объектов класса Human демонстрирует, как можно выделить память под массив из пяти объектных переменных типа Human:

Human[] humans = new Human[5];


На этом этапе каждый элемент массива humans является null, поскольку объекты еще не были созданы и присвоены элементам массива. Для того чтобы использовать элемент массива для хранения объекта, необходимо явно создать объект и присвоить его одному из элементов массива. Это делается с помощью оператора new и конструктора класса:

humans[2] = new Human(“Marsel”);

В этом примере объект класса Human с именем "Marsel" создается и его ссылка присваивается третьему элементу массива humans (поскольку индексация элементов массива начинается с нуля). Таким образом, элемент массива humans[2] теперь ссылается на конкретный объект, в то время как остальные элементы массива до сих пор имеют значение null, если только для них не были созданы и присвоены другие объекты.

### Методы экземпляров

Методы экземпляра являются ключевым компонентом объектно-ориентированного программирования, предоставляя объектам определенное поведение в дополнение к их состоянию. В отличие от статических методов, которые используют модификатор static, методы экземпляра вызываются на уровне конкретного объекта и могут взаимодействовать с его полями и другими методами. Таким образом, методы экземпляра могут использовать и модифицировать данные, хранящиеся в объекте, обеспечивая тем самым динамическое поведение объектов в зависимости от их текущего состояния.



    class Car {
    double fuelVolume = 0; // объем топлива в литрах
    double maxFuelVolume; // объем бака
    double mileage = 0; // пробег в километрах
    double fuelConsumption; // расход топлива на 100 км
    
    Car(double maxFuelVolume, double fuelConsumption) {
        this.maxFuelVolume = maxFuelVolume;
        this.fuelConsumption = fuelConsumption;
     }
    
    // метод для заправки автомобиля
     void refuel(double liters) {
        if (fuelVolume + liters > maxFuelVolume) {
            fuelVolume = maxFuelVolume;
        } else {
            fuelVolume += liters;
        }
     }
     }



В примере с классом Car, представлены несколько полей, описывающих состояние автомобиля: fuelVolume (объем топлива), maxFuelVolume (максимальный объем топливного бака), mileage (пробег) и fuelConsumption (расход топлива на 100 км). Конструктор класса инициализирует некоторые из этих полей, предоставляя основу для дальнейшей работы с объектами Car.

Метод экземпляра refuel, определенный в классе Car, демонстрирует типичное поведение, которое может быть реализовано с использованием методов экземпляра. Этот метод позволяет заправлять автомобиль определенным количеством литров топлива. Внутри метода происходит проверка, чтобы убедиться, что после заправки объем топлива не превышает максимально возможный для топливного бака. Если добавляемое количество топлива приведет к переполнению, объем топлива устанавливается на максимально возможный уровень. В противном случае к текущему объему топлива добавляется указанное количество литров.

Car polo = new Car(45, 6);
polo.refuel(10); // вызов метода объекта

Вызов метода refuel для объекта polo иллюстрирует, как методы экземпляра используются для взаимодействия с конкретными объектами. Каждый объект класса Car может иметь различные значения своих полей, и методы экземпляра позволяют управлять этими значениями индивидуально для каждого объекта, изменяя его состояние в соответствии с выполненными действиями. Такой подход обеспечивает гибкость и мощь объектно-ориентированного программирования, позволяя создавать сложные системы с динамически взаимодействующими компонентами.

### Методы с возвратом значения

Методы не только могут выполнять определенные действия с объектами, но и возвращать значения, предоставляя тем самым возможность для взаимодействия с вызывающим кодом. Эта возможность делает методы гибкими инструментами для обработки данных, выполнения вычислений и принятия решений в зависимости от текущего состояния объекта.

    class Car {
    // …
    boolean go(double kilometers) {
    // Рассчитываем, сколько топлива потребуется                            
    double fuelNeeded = (kilometers * fuelConsumption) / 100;
    // Проверяем, хватит ли топлива для поездки
        if (fuelVolume >= fuelNeeded) {
            fuelVolume -= fuelNeeded; // Уменьшаем объем 
            mileage += kilometers; // Увеличиваем пробег
            return true; // Поездка завершилась успешно
        } else {
            return false; // Не хватило топлива для поездки
        }
    }
    }


```
Car polo = new Car(45, 6);
polo.refuel(10);

if (polo.go(5)) { // вызов метода объекта
System.out.println(“Успешная поездка”);
} else {
System.out.println(“Что-то пошло не так…”);
}
```

В примере с классом Car, представлен метод go, который демонстрирует использование возвращаемых значений. Метод go принимает в качестве параметра количество километров, которое автомобиль должен проехать, и возвращает логическое значение (boolean), указывающее на успех или неудачу попытки совершить поездку.
Внутри метода сначала рассчитывается, сколько топлива потребуется для поездки на указанное расстояние. Затем производится проверка, хватит ли в баке топлива для этой поездки. Если топлива достаточно, метод уменьшает объем топлива в баке на расчетное количество, увеличивает пробег автомобиля и возвращает значение true, сигнализируя об успешном завершении поездки. В противном случае, если топлива не хватает, метод возвращает false, указывая на то, что поездка не может быть совершена.

Вызов метода go для объекта polo и последующая проверка возвращаемого значения позволяют вызывающему коду адекватно реагировать на результаты выполнения метода. В данном случае, если метод возвращает true, на консоль выводится сообщение об успешной поездке, в противном случае сообщается о неудаче.

Таким образом, использование возвращаемых значений методами экземпляра класса позволяет не только изменять состояние объекта, но и предоставлять информацию о результате выполненных операций, что делает взаимодействие с объектами более контролируемым и предсказуемым. Это значительно расширяет возможности программирования, позволяя разработчикам создавать сложные логические структуры и алгоритмы обработки данных.
Методы и состояние объектов

Методы, применяемые к объектам, играют центральную роль в управлении их состоянием. Эти методы позволяют не только выполнять операции, связанные с данными объекта, но и изменять его внутренние поля, тем самым воздействуя на состояние объекта. Особенностью таких методов является то, что они взаимодействуют исключительно с состоянием объекта, на котором были вызваны, не затрагивая состояние других объектов того же класса.


Car polo = new Car(45, 6);
Car bmw = new Car(68, 6.5);

polo.go(10);
bmw.go(15);

Пример с автомобилями polo и bmw, созданными из класса Car, наглядно демонстрирует эту концепцию. Каждый объект имеет свои индивидуальные характеристики, такие как объем топливного бака и расход топлива, заданные при их создании. Когда метод go вызывается для каждого из этих автомобилей с различными параметрами расстояния, влияние этого метода ограничивается только тем объектом, у которого он был вызван. Так, выполнение метода go для объекта polo воздействует на его собственные поля fuelVolume и mileage, изменяя их в соответствии с переданным расстоянием, аналогично и для объекта bmw — изменения касаются только его состояния.




</details>
